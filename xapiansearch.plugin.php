<?php

/* The Xapian PHP bindings need to be in the path, and the extension loaded */
include_once "xapian.php"; 

// TODO: Add slash automatically to directory if not
// TODO: do install doc/guide
// TODO: Test on PHPIR code base
// TODO: Test on 0.7 release
// TODO: Test spelling and similarity on live PHPIR code/theme

// TODO: Look for process for adding a plugin to /extras
// TODO: update github
// TODO: Put zip version on github
// TODO: Put onto live PHPIR
// TODO: Email to Habari list with functionality  (search, spelling, suggest) and example

/**
 * Xapian based search plugin for Habari.
 * 
 * @todo Support for remote backends so Xapian can be elsewhere (via FormUI)
 * @todo Better support for pagination count system
 * @todo Split Xapian specific stuff out, and allow for different engines
 * @todo Handle error from opening database
 * @todo Allow filtering based on tags
 * @todo Sorting by other than relevance (date?)
 * @todo Caching on get_similar_posts
 * @todo Index comments as a lower weighted set of terms on their posts
 * 
 * @link http://xapian.org
 */
class XapianSearch extends Plugin
{
	/* 
		Xapian's field values need to be numeric,
		so we define some constants to help them 
		be a bit more readable.
	*/
	const XAPIAN_FIELD_URL = 0;
	const XAPIAN_FIELD_TITLE = 1;
	const XAPIAN_FIELD_PUBDATE = 2;
	const XAPIAN_FIELD_CONTENTTYPE = 3;
	const XAPIAN_FIELD_USERID = 4;
	const XAPIAN_FIELD_ID = 5;
	
	/* Std prefix from Xapian docs */
	const XAPIAN_PREFIX_UID = 'Q';
	
	/** 
	 *	Used to know whether we should overwrite
	 *	an existing database.
	 */
	const INIT_DB = 1;
	
	/**
	 * Constant for the option value for the index location
	 */
	const PATH_OPTION = 'xapiansearch__xapian_db_path';
	
	/**
	 * The path to the index file
	 */
	private $_indexPath; 
	
	/**
	 * The handle for the Xapian DB
	 * @var XapianDatabase
	 */
	private $_database;
	
	/**
	 * The last search query performed
	 */
	private $_lastSearch;
	
	/**
	 * The spelling correction, if needed
	 */
	private $_spelling = '';
	
	/**
	 * The current stemming locale
	 */
	private $_locale;
	
	/**
	 * Map of locales to xapian stemming files
	 */
	private $_stem_map = array(
		'da' => 'danish', // check
		'de' => 'german',
		'en' => 'english',
		'es' => 'spanish', 
		'fi' => 'finnish',
		'fr' => 'french',
		'hu' => 'hungarian', // check
		'it' => 'italian', //check
		'nl' => 'dutch', // check
		'no' => 'norwegian',
		'po' => 'portuguese', // check
		'ro' => 'romanian', //check
		'ru' => 'russian',
		'sw' => 'swedish', //check
		'tu' => 'turkish', //check
		'zh' => false // check
	);
	
	/**
	 * The default stemmer to be used if not
	 * matching locale is found. If false, 
	 * no stemming will be performed. 
	 */
	private $_default_stemmer = false;
	
	/**
	 * Indicate whether the plugin is properly initialised
	 */
	private $_enabled;
	
	/**
	 * Null the Xapian database to cause it to flush
	 */
	public function __destruct() 
	{
		$this->_database = null; // flush xap
	}
	
	/**
	 * Initialize some internal values when plugin initializes
	 */
	public function action_init()
	{
		$this->init_paths();
		if ( !is_writable( $this->_rootPath ) ) {
			$this->_enabled = false;
			Session::error( 'Init failed, Xapian directory is not writeable. Please update configuration with a writeable directiory.', 'Xapian Search' );
			//Plugins::deactivate_plugin( __FILE__ ); //Deactivate plugin
			Utils::redirect(); //Refresh page. 
		}
		$this->add_template( 'searchspelling', dirname(__FILE__) . '/searchspelling.php' );
		$this->add_template( 'searchsimilar', dirname(__FILE__) . '/searchsimilar.php' );
		$this->_enabled = true;
	}
	
	/**
	 * Activate the plugin, clearing the database if it exists, and reindexing
	 * all published posts.
	 */
	public function action_plugin_activation( $file ) 
	{
		// Test the lib is there
		if( !class_exists("XapianTermIterator") ) {
			Session::error( 'Activation failed, Xapian does not seem to be installed.', 'Xapian Search' );
			Plugins::deactivate_plugin( __FILE__ );
		}
		$this->reindex_all();
	}
	
	/**
	* Add actions to the plugin page for this plugin
	* The authorization should probably be done per-user.
	*
	* @param array $actions An array of actions that apply to this plugin
	* @param string $plugin_id The string id of a plugin, generated by the system
	* @return array The array of actions to attach to the specified $plugin_id
	*/
	public function filter_plugin_config( $actions, $plugin_id )
	{
		if ( $plugin_id == $this->plugin_id() ){
			$actions[] = 'Configure';
		}

		return $actions;
	}
	
	/**
	* Respond to the user selecting an action on the plugin page
	*
	* @param string $plugin_id The string id of the acted-upon plugin
	* @param string $action The action string supplied via the filter_plugin_config hook
	*/
	public function action_plugin_ui( $plugin_id, $action )
	{
		if ( $plugin_id == $this->plugin_id() ){
			switch ( $action ){
				case 'Configure' :
					$ui = new FormUI( strtolower( get_class( $this ) ) );
					$ui->append( 'text', 'xapian_path', 'option:' . self::PATH_OPTION, _t('The location where Xapian will create the search database.'));
					$ui->append( 'submit', 'save', _t( 'Save' ) );
					$ui->set_option( 'success_message', _t('Options saved') );
					$ui->on_success( array( $this, 'updated_config' ) );
					$ui->out();
					break;
			}
		}
	}
	
	/**
	 * Callback from config form submit. Store the details if the location is writeable.
	 *
	 * @param FormUI $ui 
	 * @return string|bool
	 */
	public function updated_config( $ui ) 
	{
		if( !is_writeable( $ui->xapian_path->value ) ) {
			$ui->set_option('success_message', _t('The location you specified is not writeable by the webserver'));
		}
		else {
			$ui->save();
			$this->reindex_all();
			return  '<p>' . _t('Xapian database updated.') . '</p>';
		}
		
		return false;
	}

	/**
	 * If a post is published, add it to the search index.
	 *
	 * @param Post $post the post being inserted
	 */
	public function action_post_insert_after( $post ) 
	{
		if ( !$this->_enabled || Post::status( 'published' ) != $post->status ) {
			return;
		}
		
		$this->open_writable_database();
		$this->index_post( $post );
	}
	
	/** 
	 * If a post is modified, update the index
	 * 
	 * @todo Better handling on published -> unpublished & unpub modify.
	 * @param Post $post the post being updated
	 */
	public function action_post_update_after( $post ) 
	{
		if( !$this->_enabled ) { 
			return; 
		}
		
		if ( Post::status( 'published' ) != $post->status ) {
			// this is a bit of a fudge, as a post may never have been added.
			$this->delete_post( $post );
			return;
		}
		$this->open_writable_database();
		$this->index_post( $post );
	}
	
	/**
	 * If a post is deleted, remove it from the index.
	 * 
	 * @param Post $post the post being deleted
	 */
	public function action_post_delete_before( $post ) 
	{
		if( !$this->_enabled ) { 
			return; 
		}
		
		$this->open_writable_database();
		$this->delete_post( $post );
	}
	
	/**
	 * Hook in to the param array in posts to allow handling
	 * the search results
	 *
	 * @param array $paramarray the array of parameters for the Posts get
	 */
	public function filter_posts_get_paramarray( $paramarray ) 
	{
		if( $this->_enabled && isset( $paramarray['criteria'] ) ) {
			
			if( $paramarray['criteria'] != '' ) {
				$this->_lastSearch = $paramarray['criteria'];
				// flag that there was a criteria, but blank it.
				$paramarray['criteria'] = '';
			}
			
			$this->open_readable_database();
			$qp = new XapianQueryParser();
			$enquire = new XapianEnquire( $this->_database );
			
			if($this->get_stem_locale()) {
				// Note, there may be a problem if this is different than at indexing time!
				$stemmer = new XapianStem( $this->get_stem_locale() );
				$qp->set_stemmer( $stemmer );	
				$qp->set_stemming_strategy( XapianQueryParser::STEM_SOME );			
			}
			$qp->set_database( $this->_database );
			$query = $qp->parse_query( $this->_lastSearch, 
					XapianQueryParser::FLAG_SPELLING_CORRECTION );
			   
			$enquire->set_query( $query );
			if( isset($paramarray['limit']) ) {
				$limit = $paramarray['limit'];
			} else {
				// magic default number from posts, probably want to change that
				$limit = Options::get('pagination') ? (int) Options::get('pagination') : 5;
				// we'll force it to match though, just in case
				$paramarray['limit'] = $limit;
			}
			
			$offset = 0;
			if( isset($paramarray['count']) ) {
				// Fudge to get pagination kicking in
				$limit = $limit * 10;
			} else if ( isset( $paramarray['page'] ) && is_numeric( $paramarray['page'] ) ) {
				// Nix the pagination on the SQL query, so it's handled in the SE instead.
				$paramarray['offset'] = '0'; 
				$offset = ( intval( $paramarray['page'] ) - 1 ) * intval( $limit );
			}

			$this->_spelling = $qp->get_corrected_query_string();
			$matches = $enquire->get_mset( $offset, $limit );

			// TODO: get count from $matches->get_matches_estimated() instead of current method
			$i = $matches->begin();
			$ids = array();
			while ( !$i->equals($matches->end()) ) {
				$n = $i->get_rank() + 1;
				$ids[] = $i->get_document()->get_value( self::XAPIAN_FIELD_ID );
				$i->next();
			}
			
			if( count($ids) > 0 ) {
				$paramarray['id'] = $ids;
				$orderby = 'CASE';
				$i = 1;
				foreach($ids as $id) {
					$orderby .= " WHEN id = " . $id . " THEN " . $i++;
				}
				$orderby .= " END";
				$paramarray['orderby'] = $orderby;
			} else {
				$paramarray['id'] = array(-1);
			}
		}
		return $paramarray;
	}
	
	/**
	 * Output data for the spelling correction theme template. By default will
	 * display a 'Did you mean?' message if spelling corrections were available,
	 * and a link to the corrected search. 
	 * 
	 * Called from theme like <code><?php $theme->search_spelling(); ?></code>
	 * USes search_spelling template.
	 * 
	 * @param Theme $theme
	 */
	public function theme_search_spelling( $theme )
	{
		if( !$this->_enabled ) { 
			return; 
		}
		
		$theme->spelling = $this->_spelling;  
		return $theme->fetch( 'searchspelling' );
	}
	
	/**
	 * Theme function for displaying similar posts to the post passed in. By default
	 * will display a list of post titles that are considered similar to the post in
	 * question. Note that the post needs to be found in the search index, so this 
	 * will only work on published items. The easiest way with unpublished would be to 
	 * index then delete the post.
	 * 
	 * Called from a theme like <code><?php $theme->similar_posts($post); ?></code>
	 * Uses search_similar template.
	 *
	 * @param Theme $theme 
	 * @param Post $post 
	 * @param int $max_recommended 
	 */
	public function theme_similar_posts( $theme, $post, $max_recommended = 5 ) 
	{
		if( $this->_enabled && $post instanceof Post && intval($post->id) > 0 ) {
			$theme->similar = $this->get_similar_posts( $post, $max_recommended );  
			$theme->base_post = $post;
			return $theme->fetch( 'searchsimilar' );
		}
	}
	
	/**
	 * Return a list of posts that are similar to the current post
	 * 
	 * @todo: Could do with some caching around this.
	 */
	public function get_similar_posts( $post, $max_recommended = 5 ) 
	{
		$guid = $this->get_uid($post);
		$posting = $this->_database->postlist_begin( $guid );
		$enquire = new XapianEnquire( $this->_database );
		$rset = new XapianRset();
		$rset->add_document( $posting->get_docid() );
		$eset = $enquire->get_eset(20, $rset);
		$i = $eset->begin();
		$terms = array();
		while ( !$i->equals($eset->end()) ) {
			$terms[] = $i->get_term();
			$i->next();
		}
		$query = new XapianQuery( XapianQuery::OP_OR, $terms );
		$enquire->set_query( $query );	
		$matches = $enquire->get_mset( 0, $max_recommended+1 );

		$ids = array();
		$i = $matches->begin();
		while ( !$i->equals($matches->end()) ) {
			$n = $i->get_rank() + 1;
			if( $i->get_document()->get_value(self::XAPIAN_FIELD_ID) != $post->id ) {
				$ids[] = $i->get_document()->get_value( self::XAPIAN_FIELD_ID );
			}
			$i->next();
		}
		if( count($ids) ) {
			return Posts::get( array('id' => $ids) );
		} else {
			return array();
		}
	}
	
	/**
	 * Return the current locale based on options
	 *
	 * @return string
	 */
	protected function get_stem_locale() {
		if(isset($this->_locale)) {
			return $this->_locale;
		}
		if ( Options::get('locale') ) {
			$locale = Options::get('locale');
		}
		else if ( Options::get( 'system_locale' ) ) {
			$locale = Options::get( 'system_locale' );
		} else {
			$locale = 'en-us';
		}
		$locale = substr($locale, 0, 2);
		$this->_locale = isset($this->_stem_map[$locale]) ? 
							$this->_stem_map[$locale] : 
							$this->_default_stemmer;
		return $this->_locale;
	}

	/**
	 * Initialise a writable database for updating the index
	 * 
	 * @param int flag allow setting the DB to be initialised with self::INIT_DB
	 */
	protected function open_writable_database( $flag = 0 ) 
	{
		// Open the database for update, creating a new database if necessary.
		if( isset($this->_database) ) {
			if( $this->_database instanceof XapianWritableDatabase ) {
				return;
			} else {
				$this->_database = null;
			}
		}

		if( strlen($this->_indexPath) == 0 ) {
			Session::error('Received a bad index path in the database opening', 'Xapian Search');
			return false;
		}

		// Create/Open or Create/Overwrite depending on whether the module is being init
		if( $flag == self::INIT_DB ) {
			$this->_database = new XapianWritableDatabase( $this->_indexPath, (int)Xapian::DB_CREATE_OR_OVERWRITE );
		} else {
			$this->_database = new XapianWritableDatabase( $this->_indexPath, (int)Xapian::DB_CREATE_OR_OPEN );
		}
		
		$this->_indexer = new XapianTermGenerator();
		
		// enable spelling correction
		$this->_indexer->set_database( $this->_database );
		$this->_indexer->set_flags( XapianTermGenerator::FLAG_SPELLING );
		
		// enable stemming
		if($this->get_stem_locale()) {
			// Note, there may be a problem if this is different than at search time!
			$stemmer = new XapianStem( $this->get_stem_locale() );
			$this->_indexer->set_stemmer( $stemmer );				
		}
	}
	
	/** 
	 * Open the database for reading
	 */
	protected function open_readable_database() 
	{
		if( !isset($this->_database) ) {
			if( strlen($this->_indexPath) == 0 ) {
				Session::error('Received a bad index path in the database opening', 'Xapian Search');
				return false;
			}
			
			$this->_database = new XapianDatabase( $this->_indexPath );
		}
	}
	
	/**
	 * Add a post to the index. Adds more metadata than may be strictly
	 * required. 
	 * 
	 * @param Post $post the post being inserted
	 */
	protected function index_post( $post ) 
	{
		$doc = new XapianDocument();
		$tags = $post->get_tags();
		if( is_array($tags) && count($tags) ) {
			foreach( $tags as $tag => $name ) {
				$doc->add_term( "XTAG" . strtolower($tag) );
			}
		}
		
		$doc->set_data( $post->content);
		$doc->add_value( self::XAPIAN_FIELD_URL, $post->permalink );
		$doc->add_value( self::XAPIAN_FIELD_TITLE, $post->title );
		$doc->add_value( self::XAPIAN_FIELD_USERID, $post->user_id );
		$doc->add_value( self::XAPIAN_FIELD_PUBDATE, $post->pubdate );
		$doc->add_value( self::XAPIAN_FIELD_CONTENTTYPE, $post->content_type );
		$doc->add_value( self::XAPIAN_FIELD_ID, $post->id );	
		$this->_indexer->set_document( $doc );
		$this->_indexer->index_text( $post->title, 50 ); // add weight to titles
		$this->_indexer->index_text( $post->content, 1 );
		$id = $this->get_uid( $post );
		$doc->add_term( $id );
		return $this->_database->replace_document( $id, $doc );
	}
	
	/**
	 * Reindex the database, and reinit paths. 
	 *
	 */
	protected function reindex_all() 
	{
		$this->init_paths(); 
		if ( !is_writable( $this->_rootPath ) ) {
			Session::error( 'Indexing failed, Xapian directory is not writeable.', 'Xapian Search' );
		}
		
		/*
		 * Helpfully, if you pass the Xapian create database null you get the error 
		 * "No matching function for overloaded 'new_WritableDatabase'"
		 * rather than anything helpful!
		 */
		$this->open_writable_database( self::INIT_DB );
		$posts = Posts::get(array(	'status' => Post::status( 'published' ),
		 							'ignore_permissions' => true,
									'nolimit' => true, // techno techno techno techno
									));
		if( $posts instanceof Posts ) {
			foreach( $posts as $post ) {
				$this->index_post( $post );
			}
		} else if( $posts instanceof Post ) {
			$this->index_post( $posts );
		}
	}
	
	/**
	 * Remove  a post from the index
	 *
	 * @param Post $post the post being deleted
	 */
	protected function delete_post( $post ) 
	{
		$this->_database->delete_document( $this->get_uid($post) );
	}
	
	/**
	 * Prefix the UID with the xapian GUID prefix.
	 *
	 * @param Post $post the post to extract the ID from
	 */
	protected function get_uid( $post ) 
	{
		return self::XAPIAN_PREFIX_UID . $post->id;
	}
	
	/**
	 * Initialise the file paths
	 */
	protected function init_paths() 
	{
		$this->_rootPath = Options::get(self::PATH_OPTION);
		if(!$this->_rootPath) {
			$this->_rootPath = HABARI_PATH . '/' . Site::get_path( 'user', true );
			Options::set(self::PATH_OPTION, $this->_rootPath);
		}
		$this->_indexPath = $this->_rootPath . 
							(substr($this->_rootPath, -1) == '/' ? '' : '/') .
							'xapian.db';
	}
}
?>